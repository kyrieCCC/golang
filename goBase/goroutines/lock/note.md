# Go语言的并发安全问题
## Go语言的并发
一个Go程序进程中，在同一个时间里面跑多个goroutine，那么这些goroutine是并发的，虽然计算机的CPU有很多的计算核心，但核心数也是较少的，而一个计算机运行的各种程序所需要的内核线程数量远远大于其核心，所以只能在CPU时间分片中来执行不同的线程，实现一个**伪并行的状态**

## 并发的安全问题
当我们的Go程序中多个协程执行同一个方法，且多个协程存在共享变量，由于这些协程的**执行顺序是不确定的**，由这些协程同步修改使用一些变量时，**由于顺序问题产生了不确定的结果**

## 并发安全的解决方法
### 1. 使用锁(lock)
#### （1）互斥锁
互斥锁是一种常用的控制共享资源访问的方法，**他能保证同时只有一个goroutine可以访问共享资源**，Go语言中使用**sync包的Mutex类型**来实现互斥锁

互斥锁的方法：func (m *Mutex) Lock()   
```go
//声明一个互斥锁
var lock sync.Mutex
```

使用互斥锁能够**保证同一时间有且只有一个goroutine进入临界区，其他的goroutine则在等待锁**；当互斥锁释放后，等待的goroutine才可以获取锁进入临界区，多个goroutine同时等待一个锁时，唤醒的策略是随机的。

#### （2）读写互斥锁
互斥锁完全是互斥的，但是很多情况下实际的场景是读多写少的，因此我们并发的去读取一个资源不涉及资源修改的时候是完全没有必要加锁的，这种场景下使用读写锁是更好的一种选择，**读写锁在Go语言中使用sync包中的RWMutex类型**。

读写锁的方法：func (rw *RWMutex) RLock()  
```go
//声明一个读写锁
var rwlock sync.RWMutex
```