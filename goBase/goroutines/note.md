# go 创建一个goroutine
首先了解goroutine是什么，这是一个类似于子线程的一个东西，但是与子线程并不相同。它们被称为 goroutines 是因为现有的术语——线程、协程、进程等——传达了不准确的含义。 goroutine 有一个简单的模型：它是一个**与同一地址空间中的其他 goroutines 并发执行的函数**。 它是**轻量级的**，只比堆栈空间的分配花费更多。 堆栈开始时很小，所以它们很便宜，并且通过根据需要分配（和释放）堆存储来增长。

Goroutines 被**多路复用**到多个 OS 线程上，因此如果一个线程应该阻塞，例如在等待 I/O 时，其他线程会继续运行。 他们的设计隐藏了线程创建和管理的许多复杂性。

使用方法：

使用 go 关键字为函数或方法调用添加前缀，以在新的 goroutine 中运行调用。 当调用完成时，goroutine 静默退出。 （效果类似于 Unix shell 在后台运行命令的 & 符号。）

例如：
```go
//下面我们通过go关键词创建了一个goroutine
go func() {
    //do something
}
```

## 协程间的通信 CSP
CSP （Communicating Sequential Processes）

在我们的go语言协程的通信当中，我们更提倡**通过通信共享内存**，而不是通过共享内存实现通信

通过通道来共享内存，就需要引入一个**通道(Channel)**的概念

### Channel通道
一个channel通道可以实现不同协程间的通信，创建一个channel可以使用**make**方法

```go 
make(chan 元素类型, [缓冲区大小])

//make方法传入两个参数，前面一个参数是一个int类型，表示一个新的通道，第二个参数也是int类型，它用来确定通道的缓冲区
```

Channel通道中又细分了两种类型，分别是
+ 无缓冲通道   make(chan int)
+ 有缓冲通道   make(chan int, 2)

从上面的make方法可以看出，**一个通道是否具有缓冲区可以看其是否定义了第二个参数**，也就是是否定义了缓冲区的大小

其中，无缓冲的通道在消息的传递时**类似同步传递**，当中不会遇到例如缓冲产生的阻塞问题；而有缓冲的通道定义了一个缓冲区，当我们的缓冲区的容量被撑满后，我们就只能进行**等待**，当缓冲区里面的任务有新的更新后才会推入新的信息

